{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/createAsyncThunk/",
    "result": {"data":{"cur":{"id":"f70a4435-1694-5cc9-bca3-13debe15f2c0","html":"<h2 id=\"-리덕스는-어떻게-관리할까\" style=\"position:relative;\"><a href=\"#-%EB%A6%AC%EB%8D%95%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%A0%EA%B9%8C\" aria-label=\" 리덕스는 어떻게 관리할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 리덕스는 어떻게 관리할까?</h2>\n<p>리덕스는 어떻게 관리할까? 프로젝트를 시작하면서 고민을 많이했다.</p>\n<p>이전 프로젝트를 할때는 redux의 action과 reducer를 직접 만들어주는 방식으로 vanilla redux로 작업을했다.</p>\n<p>마지막 6주 협업을 진행하게 되면서 분명 프로젝트의 규모가 커질것이라고 생각했고 redux-createAsyncThunk를 사용해서 비동기 미들웨어와 리듀서들을 조금더 효율적이고 간결하게 관리하기로 했다.</p>\n<h3 id=\"create-async-thunk\" style=\"position:relative;\"><a href=\"#create-async-thunk\" aria-label=\"create async thunk permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Create Async Thunk</h3>\n<ul>\n<li>\n<p>redux 에서 비동기 처리를 할경우 보통 thunk, saga, redux-observable 등의 미들웨어를 사용하여 한개의 비동기 액션에 대해 pending(비동기 호출 전), success(비동기 호출 성공), failure(비동기 호출 실패) 의 상태를 생성하여 처리하는 경우가 많다.</p>\n</li>\n<li>\n<p>이때 각 상태를 만드는것은 각자 유틸 패키지를 받거나 직접 구현하여서 사용하였는데 이를 redux-toolkit 에서 createAsyncThunk 을 통해 구현이 가능하다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">>></span> redux<span class=\"token operator\">/</span>async<span class=\"token operator\">/</span>user\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> signupUserDB <span class=\"token operator\">=</span> <span class=\"token function\">createAsyncThunk</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"user/signup\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">data<span class=\"token punctuation\">,</span> thunkAPI</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">//회원가입 요청 api</span>\n            <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> userApi<span class=\"token punctuation\">.</span><span class=\"token function\">signup</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>ok<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// 회원가입 성공시 리듀서로 성공 여부 반환</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 에러 메세지 반환</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>err<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>ok<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// 이메일 중복 등  서버 pre set 에러 메세지 반환</span>\n                Sentry<span class=\"token punctuation\">.</span><span class=\"token function\">captureException</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">error, 회원가입 서버 : </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>err<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> thunkAPI<span class=\"token punctuation\">.</span><span class=\"token function\">rejectWithValue</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                Sentry<span class=\"token punctuation\">.</span><span class=\"token function\">captureException</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">error, 회원가입 통신 : </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>err<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">// 서버 또는 api 통신중 발생하는 에러 메세지 반환</span>\n                Swal<span class=\"token punctuation\">.</span><span class=\"token function\">fire</span><span class=\"token punctuation\">(</span>\n                    <span class=\"token string\">\"에러\"</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token string\">\"회원가입에 실패하였습니다. 다시 시도해주세요!\"</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token string\">\"error\"</span><span class=\"token punctuation\">,</span>\n                <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> thunkAPI<span class=\"token punctuation\">.</span><span class=\"token function\">rejectWithValue</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">.</span>errorMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p><strong>createAyncThunk</strong>를 사용해서 회원가입 비동기 액션을 만들어줬다. 회원가입 페이지에서 아래와같이 해당 thunk를 dispath() 함수를 통해서 호출해주면 첫번째 파라미터로 선언한 액션 이름 에 <strong>pending, fulfilled, rejected 의 상태에 대한 action 을 자동으로 생성해준다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\n<span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token function\">signupUserDB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>유저정보<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span>signupUserDB<span class=\"token punctuation\">.</span>pending<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            state<span class=\"token punctuation\">.</span>isFetching <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">[</span>signupUserDB<span class=\"token punctuation\">.</span>fulfilled<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> payload <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            state<span class=\"token punctuation\">.</span>isFetching <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            state<span class=\"token punctuation\">.</span>errorMessage <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n            state<span class=\"token punctuation\">.</span>isSignupSuccess <span class=\"token operator\">=</span> payload<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">[</span>signupUserDB<span class=\"token punctuation\">.</span>rejected<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> payload<span class=\"token operator\">:</span> errorMessage <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            state<span class=\"token punctuation\">.</span>errorMessage <span class=\"token operator\">=</span> errorMessage<span class=\"token punctuation\">;</span>\n            state<span class=\"token punctuation\">.</span>isFetching <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>이런식으로 rejected되었을때 상태를 바로 접근할 수 있어서 서버에서 보내주는 에러 메세지나 예상치 못하게 발생하는 에러에 대한 예외처리를 할 수 있었다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EB%A6%AC%EB%8D%95%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%A0%EA%B9%8C\">🤔 리덕스는 어떻게 관리할까?</a></p>\n<ul>\n<li><a href=\"#create-async-thunk\">Create Async Thunk</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"🤔 리덕스는 어떻게 관리할까? 리덕스는 어떻게 관리할까? 프로젝트를 시작하면서 고민을 많이했다. 이전 프로젝트를 할때는 redux의 action과 reducer를 직접 만들어주는 방식으로 vanilla redux로 작업을했다. 마지막 6주 협업을 진행하게 되면서 분명 프로젝트의 규모가 커질것이라고 생각했고 redux-createAsyncThunk를 사용해서 비동기 미들웨어와 리듀서들을 조금더 효율적이고 간결하게 관리하기로 했다. Create Async Thunk redux 에서 비동기 처리를 할경우 보통 thunk, saga, redux-observable 등의 미들웨어를 사용하여 한개의 비동기 액션에 대해 pending(비동기 호출 전), success(비동기 호출 성공), failure(비동기 호출 실패) 의 상태를 생성하여 처리하는 경우가 많다. 이때 각 상태를 만드는것은 각자 유틸 패키지를 받거나 직접 구현하여서 사용하였는데 이를 redux-toolkit 에서 createA…","frontmatter":{"date":"July 12, 2021","title":"리덕스 createAsyncThunk로 비동기 처리하기","categories":"프론트엔드","author":"장희성","emoji":"✏️"},"fields":{"slug":"/createAsyncThunk/"}},"next":{"id":"9d8cc037-4695-54d5-b98c-e81fa24f2f3f","html":"<h2 id=\"보초법-sentinel-method\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EC%B4%88%EB%B2%95-sentinel-method\" aria-label=\"보초법 sentinel method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보초법 (sentinel method)</h2>\n<p>여러가지 배열 검색 방법들중 선형검색은 배열의 처음부터 마지막 또는 찾고자 하는 데이터가 나올때까지 순차적으로 모든 데이터를 비교하는 방법이다.</p>\n<h4 id=\"간단한-코드-예제\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%98%88%EC%A0%9C\" aria-label=\"간단한 코드 예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 코드 예제</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">linear_search</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    i <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n        <span class=\"token keyword\">if</span> l<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> value<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> i\n        i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code></pre></div>\n<p>위 선형 검색은 루프가 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 계속 반복하면 종류 조건을 검사하는 cost를 무시할 수 없다.</p>\n<blockquote>\n<p>선형 검색의 종류 조건</p>\n</blockquote>\n<ol>\n<li>i == len(l)가 성립하면 (실패)</li>\n<li>a[i] == value가 성립하면 (성공)</li>\n</ol>\n<p>이과정을 줄여주는 것이 <strong>보초법(sentinel method)이다</strong>.</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/87ef5cba-992c-4b57-80f1-bbcde047fd11/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-06-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.44.52.png\" alt=\"\"></p>\n<ul>\n<li>\n<p>검색하고자 하는 키값을 배열의 맨 끝에 넣어준다.</p>\n</li>\n<li>\n<p>이때 저정하는 값을 <strong>보초</strong>라고 한다.</p>\n</li>\n<li>\n<p>위 그림에서 볼 수 있듯이, 기존 데이터에 찾고자하는 키 값이 존재하지 않아도, 보초를 통해 검색할 값을 찾았나?라는 질문에 True를 반환하게된다.</p>\n</li>\n<li>\n<p>이렇게 if 조건을 하나 단축할 수 있으며, return에서 찾은 데이터의 인덱스가 배열의 길이와 같은지 검사만 해주면 된다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%B3%B4%EC%B4%88%EB%B2%95-sentinel-method\">보초법 (sentinel method)</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%98%88%EC%A0%9C\">간단한 코드 예제</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 21, 2021","title":"보초법","categories":"알고리즘","author":"장희성","emoji":"✏️"},"fields":{"slug":"/sentinel method/"}},"prev":{"id":"06ac48d0-a881-5ea2-ab15-bda0459dff1e","html":"<h1 id=\"graphql이-도대체-뭐야\" style=\"position:relative;\"><a href=\"#graphql%EC%9D%B4-%EB%8F%84%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC\" aria-label=\"graphql이 도대체 뭐야 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL이 도대체 뭐야?</h1>\n<p><strong>GraphQL 얘기를 주변에서 너무 많이 들었다.</strong> 프로젝트 발표에서도 면접에서도 GraphQL 관련 질문을 받았는데..그동안 계속된 프로젝트로 새로운 기술을 배울 시간이 없었는데 도대체 GraphQL 뭔지 공부 해봐야겠다.</p>\n<p>GraphQL docs에서 제공한는 튜토이얼을 따라하기 전에 개념부터 잡고가야겠다는 생각을 했는데 마침!! kakao tech에서 정리해놓은 블로그 글을 찾았다.</p>\n<p><a href=\"https://tech.kakao.com/2019/08/01/graphql-basic/\">카카오 테크 참고 링크</a></p>\n<p>GraphQL(이하 gql)은 페이스북에서만든 쿼리 언어이고 아직 세상에 나온지 얼마되지 않은 새로운 친구이지만 2016년부터 가파르게 사용자가 늘어나고 있다고 한다.</p>\n<p>위에서도 언급했듯이 gql은 sql과 마찬가지로 데이터를 효율적으로 요청하기 위해 사용되는 언어이지만 구조적을 큰 차이가 있고 사용 목적 또한 다르다.</p>\n<p>sql문이 데이터베이스에서 데이터를 효율적을 가져오기 위해서 사용된다면 <strong>gql은 웹 클라이언트가 서버로부터 효율적을 데이터를 받아오기 위해서 만들어진 쿼리 언어이다.</strong></p>\n<ul>\n<li>sql: 주로 백엔드 시스템에서 작성하고 호출</li>\n<li>gql: 클라이언트 시스템에서 작성하고 호출</li>\n</ul>\n<p>웹 클라이언트가 서버로부터 데이터를 받아오는 쿼리 언어? 여기서부터 개념이 헷갈리기 시작했다. 내가 기존에 알고있던 쿼리언어는 백엔드 서버에서 클라이언트 요청을 받아 데이터베이스에 접근해 알맞는 데이터를 찾기위해 사용되는것으로 알고있는데.. <strong>클라이언트에서 쿼리문을 작성한다고?</strong></p>\n<p>사용 예시와 기존 RestAPI를 비교하면서 조금은 의문점이 풀렸다.</p>\n<h2 id=\"rest-api의-어떤-부분을-해결하려고-했나\" style=\"position:relative;\"><a href=\"#rest-api%EC%9D%98-%EC%96%B4%EB%96%A4-%EB%B6%80%EB%B6%84%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%A0%A4%EA%B3%A0-%ED%96%88%EB%82%98\" aria-label=\"rest api의 어떤 부분을 해결하려고 했나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST API의 어떤 부분을 해결하려고 했나?</h2>\n<blockquote>\n<p>Rest API와 비교: <strong>REST API는 URL, METHOD등을 조합하기 때문에 다양한 Endpoint가 존재 합니다.</strong> 반면, <strong>gql은 단 하나의 Endpoint가 존재 합니다.</strong>\n출처: <a href=\"https://tech.kakao.com/2019/08/01/graphql-basic/\">카카오 테크 REST API와 비교</a></p>\n</blockquote>\n<h3 id=\"-rest-api는-다양한-endpoint가-존재하고-gql은-단-하나의-endpoint만-존재한다\" style=\"position:relative;\"><a href=\"#-rest-api%EB%8A%94-%EB%8B%A4%EC%96%91%ED%95%9C-endpoint%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%98%EA%B3%A0-gql%EC%9D%80-%EB%8B%A8-%ED%95%98%EB%82%98%EC%9D%98-endpoint%EB%A7%8C-%EC%A1%B4%EC%9E%AC%ED%95%9C%EB%8B%A4\" aria-label=\" rest api는 다양한 endpoint가 존재하고 gql은 단 하나의 endpoint만 존재한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 Rest API는 다양한 Endpoint가 존재하고, gql은 단 하나의 Endpoint만 존재한다?</h3>\n<p>기존에 RestAPI 방법론으로 api를 설계한다면 필요한 resource 즉 클라이언트에서 필요한 데이터 set 별로 별도의 endpoint를 가지게 된다. 가장 최근에 진행했던 <a href=\"https://github.com/heesungjang/UFO-frontend\">UFO</a> 프로젝트의 api 문서를 살펴보자.</p>\n<ul>\n<li>/free/post</li>\n<li>/free/post/:post_id</li>\n<li>/free/post/:post_id/view_count</li>\n<li>/free/post/:post_id (delete)</li>\n<li>/free/post/:post_id (put)</li>\n<li>/free/post/:post_id/like</li>\n</ul>\n<p>이런식으로 비슷하지만 다른 API를 생성하게되고 만약 서비스가 더 커지게 된다면 관리해야하는 endpoint가 N(resource)+1만큼 많아지게 된다.</p>\n<h3 id=\"-overfetching--underfetching\" style=\"position:relative;\"><a href=\"#-overfetching--underfetching\" aria-label=\" overfetching  underfetching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 OverFetching &#x26; UnderFetching</h3>\n<p>기존 RestAPI은 Over fehing과 Under ftching이라는 문제점도 가지고있다. 예를들어 아래 데이터는 UFO 프로젝트에서 유저 정보를 요청하면 받아오는 값이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\nok<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\nresult<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\nuser_id<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\nemail<span class=\"token operator\">:</span> <span class=\"token string\">\"user1@naver.com\"</span><span class=\"token punctuation\">,</span>\nnickname<span class=\"token operator\">:</span> \"user1\npassword<span class=\"token operator\">:</span> <span class=\"token string\">\"1234\"</span><span class=\"token punctuation\">,</span>\nschool_auth<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\nschool_email<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\ncountry_id<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\nuniv_id<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\ncreatedAt<span class=\"token operator\">:</span> <span class=\"token string\">\"2021-07-26T10:35:39.000Z\"</span><span class=\"token punctuation\">,</span>\nupdatedAt<span class=\"token operator\">:</span> <span class=\"token string\">\"2021-07-26T10:35:39.000Z\"</span><span class=\"token punctuation\">,</span>\nuniversity<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\ncountry<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/d0b27e62-adcb-41de-9f86-f929fa30eef2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-16%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.26.56.png\" alt=\"\"></p>\n<p>어떤 문제가 있을까? 바로 <strong>OverFetching</strong>이다. 유저 정보가 모두 필요한 부분도 있겠지만 만약 로그인 사용자의 닉네임을 헤더에 보여주기 위해서 데이터를 요청할때 유저의 닉네임을 사용하기 위해 다른 불필요한 데이터까지 모두 받아오게 되는 경우가 발생한다.</p>\n<h3 id=\"graphql로-데이터-받아오기\" style=\"position:relative;\"><a href=\"#graphql%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%9B%EC%95%84%EC%98%A4%EA%B8%B0\" aria-label=\"graphql로 데이터 받아오기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL로 데이터 받아오기</h3>\n<p>반면 gql은 이러한 Over-fetching 문제가 발생하지 않는다. 데이터를 요청하는 시점에 어떤 정보를 원하는지에 대한 컨트롤이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">요청 쿼리\nquery<span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">user</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user<span class=\"token operator\">:</span><span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    nickname\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n반환 쿼리\n<span class=\"token punctuation\">{</span>\n<span class=\"token string\">\"data\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token string\">\"user\"</span><span class=\"token operator\">:</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">\"nickname: \"</span>jane\"<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Under Fetching</strong>도 gql에서 손쉽게 해결이 가능한거 같다. under fetchin은 어떤 특정 데이터를 가져오기 이전에 다수의 데이터 요청이 필요한 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javacript\"><pre class=\"language-javacript\"><code class=\"language-javacript\">/feed/ --&gt; /notify/ --&gt; /user/1\n</code></pre></div>\n<p>이런식으로 하나의 유요한 정보를 받기 위해서 그때마다 여러개의 api요청을 연속적으로 호출하게된다. 단순히 요청의 단계가 많아지는 문제도 있지만 비동기 처리를 하는것도 어려워질수 있을꺼 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">요청<span class=\"token operator\">:</span>\nquery <span class=\"token punctuation\">{</span>\n feed <span class=\"token punctuation\">{</span>\n  comments\n  likeNumber\n <span class=\"token punctuation\">}</span>\n notifications <span class=\"token punctuation\">{</span>\n  isRead\n <span class=\"token punctuation\">}</span>\n user <span class=\"token punctuation\">{</span>\n  username\n  profilePit\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n응답<span class=\"token operator\">:</span>\n<span class=\"token punctuation\">{</span>\n feed<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n   comments<span class=\"token operator\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n   likeNumber<span class=\"token operator\">:</span> <span class=\"token number\">20</span>\n  <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n notifications<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    isRead<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n <span class=\"token punctuation\">{</span>\n <span class=\"token punctuation\">,</span><span class=\"token operator\">...</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>반면 gql은 한 번의 쿼리에 내가 정확하게 원하는 정보들을 받아올 수 있기 때문에, 여러 개의 endpoint를 가지지 않고 여러번의 API를 호출하는 일이 없어진다는 장점이있다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#rest-api%EC%9D%98-%EC%96%B4%EB%96%A4-%EB%B6%80%EB%B6%84%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%A0%A4%EA%B3%A0-%ED%96%88%EB%82%98\">REST API의 어떤 부분을 해결하려고 했나?</a></p>\n<ul>\n<li><a href=\"#-rest-api%EB%8A%94-%EB%8B%A4%EC%96%91%ED%95%9C-endpoint%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%98%EA%B3%A0-gql%EC%9D%80-%EB%8B%A8-%ED%95%98%EB%82%98%EC%9D%98-endpoint%EB%A7%8C-%EC%A1%B4%EC%9E%AC%ED%95%9C%EB%8B%A4\">🤔 Rest API는 다양한 Endpoint가 존재하고, gql은 단 하나의 Endpoint만 존재한다?</a></li>\n<li><a href=\"#-overfetching--underfetching\">🤔 OverFetching &#x26; UnderFetching</a></li>\n<li><a href=\"#graphql%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%9B%EC%95%84%EC%98%A4%EA%B8%B0\">GraphQL로 데이터 받아오기</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 16, 2021","title":"Graphql은 REST API의 어떤점을 해결해주나?","categories":"프론트엔드","author":"장희성","emoji":"✏️"},"fields":{"slug":"/graphql-intro/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/createAsyncThunk/","nextSlug":"/sentinel method/","prevSlug":"/graphql-intro/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}