{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/자료구조",
    "result": {"pageContext":{"currentCategory":"자료구조","categories":["All","프론트엔드","자료구조","알고리즘"],"edges":[{"node":{"id":"58ec3cec-355c-5b39-81e4-0d924044ff07","excerpt":"#️⃣ 해시 👨‍🏫 해쉬 테이블(Hash Table)은 “키” 와 “데이터”를 저장함으로써 즉각적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 빠른 검색과 저장이 특징인 자료구조이다. 해시 테이블의 형태의 자료구조는 여러 언어에서 이미 우리가 많이 사용하고 있다. 자바스크립트의 오브젝트 또는 파이썬의 딕셔너리를 해시 테이블과 같다고 보면 된다 (사실 완저히 같다고 할 수는 없지만 현재로서는 이렇게 이해하는게 가장 좋을거 같다). “데이터를 빠르게 검색할 수 있다”라는 해시 테이블의 장점은 우리가 딕셔너리에서 또는 자바스크립트 오브젝트에서 index가 아닌 key 값으로 특정 데이터에 접근할 때를 생각하면 된다. 예를 들어서 위에 예시로 작성한 dict 오브젝트에 2개의 데이터 쌍이 아닌 100개의 key value 쌍의 데이터가 있다고 생각해보자. 아무리 많은 데이터가 있어도 key 값만 가지고 있다면 바로 원하는 데이터에 접근할 수 있고 따라서 해시테이블의 평균 시간복잡도는 O(…","fields":{"slug":"/hash-table/"},"frontmatter":{"categories":"자료구조","title":"해시 테이블 (hash table)","date":"November 09, 2021"}},"next":{"fields":{"slug":"/lazy-state-initialization/"}},"previous":{"fields":{"slug":"/Swr/"}}},{"node":{"id":"46b8114b-691f-5c0b-a2d1-c1188bf6f21b","excerpt":"✏️ 스택 (stack) 스택은 후입선출 구조 (LIFO, Last In First Out) 구조라고 해서 한쪽 끝으로만 자료를 넣고 뺄 수 있는 자료 구조이다. 스택이 사용되는 예시 컴퓨터의 되돌리기(Ctrl + Z) 기능: 직전에 했던 행동을 되돌고 싶을 때 사용하는 기능으로, 이를 위해서는 내가 했던 행동들을 순서대로 기억해야 하므로 스택을 사용한다. 📌 특징 스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을수 있으며 데이터 접근 또한 데이터가 삽입된 top을 통해서만 접근이 가능하다. 스택의 가장 상위에 위치하는 자료는 가장 최근에 들어온 자료이며, 새로 삽입되는 자료는 top이 가리키는 자료의 위에 쌓이게 된다. 스택에서 자료를 삭제할 때도 top을 통해서만 가능하다. 스택에서 top을 통해 삽입하는 연산을 **‘push’ , top을 통한 삭제하는 연산을 ‘pop’**이라고 한다. 스택 자료구조의 기능들을 코드로 직접 구현해보자. 1. Push: 맨 …","fields":{"slug":"/stack-and-queue/"},"frontmatter":{"categories":"자료구조","title":"스택(stack)& 큐(queue)","date":"June 20, 2021"}},"next":{"fields":{"slug":"/Big-O/"}},"previous":{"fields":{"slug":"/sentinel method/"}}},{"node":{"id":"98ad3573-309e-56f9-a3ad-f470702b58c2","excerpt":"링크드 리스트란?  링크드 리스트는 기존 배열 구조와 마찬가지로 선형 데이터 자료구조를 가진다. 배열에서는 담고있는 데이터 자체가 연속적으로 저장되어 있다면, 링크드리스트는 노드들이 포인터를 통해 연결 관계를 유지하는 리스트이며, 노드는 데이터를 저장하는 부분, 다음 노드를 가르키는 부분으로 구성되어있다. 링크리스트 장/단점: 장점 삽입과 삭제가 O(1)에 이루어진다. 삽입과 삭제를 할 때마다 동적으로 링크드 리스트의 크기가 결정되므로 전통적인 배열(Array)에 비해 처음부터 큰 공간을 할당할 필요가 없어진다. 메모리 관리가 용이하다. 단점 Random Access, 즉 배열처럼 index를 통해 탐색이 불가능하다. 탐색이 O(N)이 걸린다. (Head부터 Tail까지 모두 탐색 시) 사실상 삽입과 삭제가 왼쪽에서(Head에서) 이루어지지 않을 경우, 결국 탐색을 먼저 해야 하기 때문에 삽입과 삭제 모두 적게는 O(k)부터 최악의 경우 O(N)까지 걸릴 가능성이 있다. (출처: …","fields":{"slug":"/Linked List/"},"frontmatter":{"categories":"자료구조","title":"Linked List","date":"June 15, 2021"}},"next":{"fields":{"slug":"/sorting/"}},"previous":{"fields":{"slug":"/binary-search/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}