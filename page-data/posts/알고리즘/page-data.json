{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/알고리즘",
    "result": {"pageContext":{"currentCategory":"알고리즘","categories":["All","프론트엔드","자료구조","알고리즘"],"edges":[{"node":{"id":"9d8cc037-4695-54d5-b98c-e81fa24f2f3f","excerpt":"보초법 (sentinel method) 여러가지 배열 검색 방법들중 선형검색은 배열의 처음부터 마지막 또는 찾고자 하는 데이터가 나올때까지 순차적으로 모든 데이터를 비교하는 방법이다. 간단한 코드 예제 위 선형 검색은 루프가 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 계속 반복하면 종류 조건을 검사하는 cost를 무시할 수 없다. 선형 검색의 종류 조건 i == len(l)가 성립하면 (실패) a[i] == value가 성립하면 (성공) 이과정을 줄여주는 것이 보초법(sentinel method)이다.  검색하고자 하는 키값을 배열의 맨 끝에 넣어준다. 이때 저정하는 값을 보초라고 한다. 위 그림에서 볼 수 있듯이, 기존 데이터에 찾고자하는 키 값이 존재하지 않아도, 보초를 통해 검색할 값을 찾았나?라는 질문에 True를 반환하게된다. 이렇게 if 조건을 하나 단축할 수 있으며, return에서 찾은 데이터의 인덱스가 배열의 길이와 같은지 검사만 해주…","fields":{"slug":"/sentinel method/"},"frontmatter":{"categories":"알고리즘","title":"보초법","date":"June 21, 2021"}},"next":{"fields":{"slug":"/stack-and-queue/"}},"previous":{"fields":{"slug":"/createAsyncThunk/"}}},{"node":{"id":"cb1ba609-d7b7-56e9-8622-fa22b6b65216","excerpt":"시간복잡도 & 공간복잡도 시간 복잡도는 코드의 실행 시간을 예측해 코드의 효율성을 나타내는 개념. 공간 복잡도는 코드의 메모리 할당이 얼마나 효율적으로 이주어지고 있는지 예측하는 개념이다. Big O 표기법 알고리즘의 성능을 수학적으로 표기하여 알고리즘의 “효율성”을 평가하는 방법. 실제 알고리즘의 정확한 러닝타임을 계산하기 보다는 알고리즘의 성능을 예측하는 것이 목표이기 때문에 Big O 표기법에서 상수는 표기하지 않는다.  O(1) -> Constant 데이터 크기에 상관없이 일정한 시간이 걸리는 알고리즘. O(n) -> Linear 선형 탐색 알고리즘과 같이 입력 테이터의 크기에 비례해 처리 시간이 증가하는 알고리즘 O(n²) -> quadratic 데이터가 증가하게되면 처리 시간이 급격하게 늘어난다.\n대표적인 예로는 이중 for문 (n² matrix)가 있다. O(nm) quadratic과 비슷하지만 두번째 loop에서 m의 크기가 n보다 작을 경우 nm으로 표기해준다. O…","fields":{"slug":"/Big-O/"},"frontmatter":{"categories":"알고리즘","title":"Big O 표기법","date":"June 19, 2021"}},"next":{"fields":{"slug":"/recursion/"}},"previous":{"fields":{"slug":"/stack-and-queue/"}}},{"node":{"id":"03fc321e-61b7-5159-bc45-8c5fb8cc7a9c","excerpt":"1. 재귀함수 📘 재귀(Recursion)은 어떠한 것을 정의할 때 자기 자신을 참조하는 것을 뜻한다. [위키백과] 어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.\n“재귀함수가 뭔가요?”\n“잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어. 마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지. 그의 답은 대부분 옳았다고 하네.\n그런데 어느날, 그 선인에게 한 선비가 찾아와서 물었어.\n“재귀함수가 뭔가요?”\n“잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을… 2. 코드 구현 숫자 세기 간단하게 60에서 0까지 숫자를 카운트하는 기능을 재귀 함수로 구현해보자. 팩토이얼 재귀함수와 관련되어 나오는 대표적인 문제인 팩토리얼 문제를 코드로 구현해보자. 팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것을 의미한다. 예제)\n3! 은 3 _ 2 _ 1 = 6,\n4! 는 4 _ 3 _ 2 _ 1 = …","fields":{"slug":"/recursion/"},"frontmatter":{"categories":"알고리즘","title":"재귀함수","date":"June 16, 2021"}},"next":{"fields":{"slug":"/binary-search/"}},"previous":{"fields":{"slug":"/Big-O/"}}},{"node":{"id":"568c79a7-da45-5fac-8938-a0b2e62940ad","excerpt":"1. 이진 탐색 배열 구조의 자료에서 특정 값을 찾는 방법은 크게 두가지가 있을 수 있다. 순차 탐색 이진탐색 순차 탐색에서는 배열의 시작부터 순차적으로 이동하며 찾고자 하는 특정 값을 모든 배열의 원소들과 비교하며 값을 찾을 때까지 반복한다. 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 출처(https://cjh5414.github.io/binary-search/) 순차 탐색과 이진탐색을 비교해보자. 순차 탐색 array 를 따라가면서 target 이 존재한다면 True 를 반환하고,\n끝까지 없다면 False 를 반환한다. 이진 탐색  1. 이진 탐색 출처(https://cjh5414.github.io/binary-search/) 순차 탐색…","fields":{"slug":"/binary-search/"},"frontmatter":{"categories":"알고리즘","title":"이진탐색","date":"June 16, 2021"}},"next":{"fields":{"slug":"/Linked List/"}},"previous":{"fields":{"slug":"/recursion/"}}},{"node":{"id":"0f9e9d50-471c-5a96-85e7-eeda71495301","excerpt":"1. 문제 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자를 모두 0, 혹은 모두 1로 같게 만들어야 한다. 할 수 있는 행동은 연속된 하나의 숫자를 잡고 모두 뒤집는 것 이다. 뒤는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다. 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오. 예제: 예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다. 접근법: 00011000에서 연속된 하나의 숫자, 즉 연속된 문자열들을 하나의 집합으로 구분하여 생각하자. 예를들어, 00011000은 000 11 000 이렇게 구간별로 나눌 수 있다. 따라서 이 경우에 1이 나오는 구간의 문자열들을…","fields":{"slug":"/reverse-string/"},"frontmatter":{"categories":"알고리즘","title":"문자열 뒤집기","date":"June 14, 2021"}},"next":{"fields":{"slug":"/sorting/"}},"previous":{"fields":{"slug":"/Linked List/"}}},{"node":{"id":"bcd5395a-292c-5d49-85e2-515194008293","excerpt":"알고리즘 공부를 시작하면서 점점 작아지는 내 모습이 안쓰러울 정도이다…처음 개발 공부를 시작할때 들었던 막막함과는 또 다른 느낌이다. 마치 끝이 보이지 않는 어두캄캄한 길을 걸어가는 느낌..다른 사람들은 당연하다고 생각하는 소스코드도 왜이렇게 이해하기가 힘든지..여튼 쉽지않은 하루를 보내고있다. ✏️ 정렬 오늘은 정렬의 여러가지 방법들을 정리하면서 배운 내용들을 다시 한번 돌아보려고 한다. 1. bubble (버블정렬) - O(n²) 버블 정렬에서는 리스트의 원소들을 처음부터 순차적으로 이동하며 인접한 두 원소의 값을 검사하고 작은 값, 또는 큰 값의 위치를 교환하며 정렬해 나가는 방법이다. 1회차의 검사가 완료되면 가장큰 원소가 자료의 맨 마지막 위치로 이동하게 되므로 2회차 검사에서는 마지막 위치의 온소는 제외하고 반목문을 실행한다. 버블 정렬의 장/단점 코드 구현이 쉽다. 최악의 경우 첫번째 위치의 원소가 마지막 위치까지 이동하기 위해서는 배열을 모든 원소들과 검사하고 교환되어…","fields":{"slug":"/sorting/"},"frontmatter":{"categories":"알고리즘","title":"정렬","date":"June 14, 2021"}},"next":{"fields":{"slug":"/list-prime-number/"}},"previous":{"fields":{"slug":"/reverse-string/"}}},{"node":{"id":"08a4ad2e-e059-5570-bf26-e04017fe5d65","excerpt":"1.문제 정수를 입력 했을 때, 그 정수 이하의 소수를 모두 반환하시오. 소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다. Input = 20 접근법: 소수는 자기와 1외에는 나눌 수 없다. 소수는 2부터 n - 1까지 어떤 소수로도 나누어 떨어지지 않는다.\n(소수인지 확인하고자 하는 수가 n 일때, n이 2와3으로 나누어 떨어지지 않는다면 2x2인 4와 2x3인 6으로도 나누어 떨어지지 않는다.) n의 제좁근 이하의 어떤 소수로도 나누어 떨어지지 않는다. 풀이법: python code: 접근법: 풀이법: python code:","fields":{"slug":"/list-prime-number/"},"frontmatter":{"categories":"알고리즘","title":"소수 나열하기 [알고리즘]","date":"June 14, 2021"}},"next":null,"previous":{"fields":{"slug":"/sorting/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}