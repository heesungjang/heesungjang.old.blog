{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"1999e58c-6523-57be-b01f-53c27dfa1025","excerpt":"클라이언트에서 외부 데이터가 필요할때 즉, 서버에 api 요청을 보내야할때 axio를 계속해서 사용 해 왔다. 그러다 얼마 전 회사에서 신규 프로젝트를 next로 개발하게 되었는데 graphql 서버와 통신하기 때문에 해당 프로젝트에서는 자연스럽게 apollo-client를 사용했지만 next 공부를 위해서 공식 문서를 둘러보다 SWR에 대해서 알게 되었다. 요즘 리액트 진영에서 핫한? 프레임워크 이기때문에 Next.js가 클라이언트 및 서버 측 렌더링을 모두 지원하는 것을 알고 있을 것이다. Next에서는 데이터를 가져오는 여러 가지 방법을 제공하는데 그중 하나가 next가 직접 개발한 SWR이다. 이며 SWR을 사용하면 컴포넌트는 지속적이며 자동으로 데이터 업데이트 스트림을 받게 되고 그로인해 UI는 항상 빠르고 반응한다고 소개한다. 이번 글에서는 기본적인 SWR 개념 및 사용법과 SWR이 제공하는 caching, pagination, revalidation 등의 기능을 살펴보…","fields":{"slug":"/SWR/"},"frontmatter":{"categories":"프론트엔드","title":"Next에서 데이터 호출하기","date":"November 21, 2021"}},"next":{"fields":{"slug":"/hash-table/"}},"previous":null},{"node":{"id":"58ec3cec-355c-5b39-81e4-0d924044ff07","excerpt":"#️⃣ 해시 👨‍🏫 해쉬 테이블(Hash Table)은 “키” 와 “데이터”를 저장함으로써 즉각적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 빠른 검색과 저장이 특징인 자료구조이다. 해시 테이블의 형태의 자료구조는 여러 언어에서 이미 우리가 많이 사용하고 있다. 자바스크립트의 오브젝트 또는 파이썬의 딕셔너리를 해시 테이블과 같다고 보면 된다 (사실 완저히 같다고 할 수는 없지만 현재로서는 이렇게 이해하는게 가장 좋을거 같다). “데이터를 빠르게 검색할 수 있다”라는 해시 테이블의 장점은 우리가 딕셔너리에서 또는 자바스크립트 오브젝트에서 index가 아닌 key 값으로 특정 데이터에 접근할 때를 생각하면 된다. 예를 들어서 위에 예시로 작성한 dict 오브젝트에 2개의 데이터 쌍이 아닌 100개의 key value 쌍의 데이터가 있다고 생각해보자. 아무리 많은 데이터가 있어도 key 값만 가지고 있다면 바로 원하는 데이터에 접근할 수 있고 따라서 해시테이블의 평균 시간복잡도는 O(…","fields":{"slug":"/hash-table/"},"frontmatter":{"categories":"자료구조","title":"해시 테이블 (hash table)","date":"November 09, 2021"}},"next":{"fields":{"slug":"/lazy-state-initialization/"}},"previous":{"fields":{"slug":"/SWR/"}}},{"node":{"id":"b475ed69-1bf7-5412-b19b-0f0e553c7480","excerpt":"Lazy initialization 🥱 <지연 초기 state> 리액트에서 특정 함수나 실행 시간이 오래 걸리는 값 비싼 연산이 필요할때 useCallback이나 useMemo로 최적화를 한다. 이번 블로그에서는 useState을 사용해서 초기 상태(state) 값을 할당할때 값 비싼 연산이 필요한 함수를 이런식으로 바로 파라미터로 전달하면 발생하는 문제점과 해결 방법을 정리해보자. 예시🕵️‍♀️  사용자가 Input창에 이름을 입력하면 입력 값을 name 값에 업데이트하고 Hello {name}으로 사용자가 입력한 이름을 화면에 그려주는 간단한 컴포넌트이다. 새로고침 이후에도 사용자가 마지막으로 입력한 값을 화면에 그려주기 위해서 useEffect의 의존 값을 name을 설정하고 name 값의 변화를 감지하면 localStorage에 저장하고 컴포넌트가 리랜더링되면 useState에서 getLocalStorageValue() 함수를 통해서 로컬스토리지 값을 초기 name 값으로 설정한다…","fields":{"slug":"/lazy-state-initialization/"},"frontmatter":{"categories":"프론트엔드","title":"useState 지연 초기 state(lazy state initialization)","date":"October 08, 2021"}},"next":{"fields":{"slug":"/react-and-dom-api/"}},"previous":{"fields":{"slug":"/hash-table/"}}},{"node":{"id":"04d974cc-c24c-5182-a14e-59136468b1d7","excerpt":"다들 처음 프로그래밍 언어 또는 웹 개발을 공부를 시작하면서 그 유명한 **“hello, world”**를 터미널 또는 브라우저에 찍어본 경험이 있을꺼다. DOM과 HTML을 어느정도는 알고있다면 “Hello, World”를 브라우저 화면에 쉽게 출력할 수 있을꺼라 생각한다. 또한 스크립트 태그 안에서 자바스크립트 코드를 통해 DOM 조작을하고 웹 페이지와 상호작용을 할 수 있다. 다양한 웹 프레임워크가 나오기 이전에는 서버에서 HTML을 생성하고 브라우저와 상호작용을 하기 위해 HTML 위에 자바스크립트 코드를 추가했다. 하지만 이러한 방식은 웹 페이지가 복잡해지고 개발적으로 요구사항이 까다로워지면서 유지보수나 성능 측면에서 문제가 발생하기 시작했고 이를 해결하기 위해 우리가 알고있는 vue나 react같은 다양한 웹 프레임워크가 등장했다. 만약 지금 리액트를 사용하지 않고 서비스를 만들어여 한다면…🥲 그만큼 리액트가 좋다 😅 그래서 뭐 DOM이 왜? 리액트는 세계에서 가장 널리…","fields":{"slug":"/react-and-dom-api/"},"frontmatter":{"categories":"프론트엔드","title":"react 컴포넌트와 DOM api","date":"October 07, 2021"}},"next":{"fields":{"slug":"/react-key-props/"}},"previous":{"fields":{"slug":"/lazy-state-initialization/"}}},{"node":{"id":"e4f812f0-91fb-5c69-a383-2fe97f7fbaf7","excerpt":"리액트 개발을 해봤다면 배열을 렌더링 할때 위와 같은 ❌ 경고 메세지를 한번쯤 봤을거다. 이번 시간에는 리액트 Element에 왜 key props가 필요하고 어떤 점을 주의해야 하는지 알아보자. 🤔 조정(Reconciliation) 리액트 문서를 먼저 살펴보자: Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다. key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다. 리액트 공식 가이드에 따르면 key props가 컴포넌트의 변화가 생겼을때 어떤 항복을 변경, 추가, 삭제할지 돕는다고 한다. 컴포넌트의 상태 값이 변경되면 렌더링 함수는 이전 요소와 현재 요소의 트리를 반환한다. React는 가장 최근의 변경 사항으로 UI를 효율적으로 업데이트하기 위해 어떤 차이가 있는지 파악해야 하고, 이 두 트리를 일치시키는 프로세스를 **조정(Reconciliation)**이라고 한다. 이때 변경 사항만 기존 render…","fields":{"slug":"/react-key-props/"},"frontmatter":{"categories":"프론트엔드","title":"리액트 key props 자세히 알아보기","date":"September 23, 2021"}},"next":{"fields":{"slug":"/jsx-and-react-component/"}},"previous":{"fields":{"slug":"/react-and-dom-api/"}}},{"node":{"id":"a398fdcb-8322-5ef5-b7ec-160e0f5f6307","excerpt":"참고: Kent C Dodds - What is JSX? 📚 JSX “This funny tag syntax is neither a string nor HTML” - 리액트 공식 문서 JSX는 Raw React API보다 직관적이며 코드를 읽을 때 이해하기 쉽게 만들어주는 syntactic sugar이다. 그치만 JSX은 그 자체로 자바스크립트는 아니기 때문에 브라우저가 이를 이해하기 위해서는 babel과 같은 코드 컴파일러가 필요하다. 실제 바벨 사이트에 들어가보면 내가 작성한 JSX 코드가 어떻게 컴파일되어 브라우저가 이해하는 형식으로 변한하는지 확인할 수 있다. 리액트 알아보기[1]에서 기존 DOM 생성을 React API를 사용해서 변경했던 코드를 JSX 문법으로 변환해보자. 📚 리액트 커스텀 컴포넌트 일반 자바스크립트에서 함수를 만들어 재사용 가능한 코드를 만드는 것과 같이 JSX또한 함수를 통해 재사용 가능한 JSX 코드를 작성할 수 있고 이를 리액트에서는 Compone…","fields":{"slug":"/jsx-and-react-component/"},"frontmatter":{"categories":"프론트엔드","title":"jsx와 리액트 컴포넌트","date":"September 20, 2021"}},"next":{"fields":{"slug":"/graphql-query-at-front/"}},"previous":{"fields":{"slug":"/react-key-props/"}}},{"node":{"id":"a9953497-4f57-5dae-bd57-5a4d6a8655d4","excerpt":"1. GraphQL이란?\n에서 GraphQL(이하 gql)의 개념을 정리하면서 gql은 클라이언트 시스템에서 쿼리문을 작성한다고 짚고 넘어갔다. 🤔 클라이언트에서 쿼리를 작성하면 실제 어떤 장점이 있을까? 프로젝트를 진행하다보면 서버 개발자와 소통은 필수이다. 진행중인 서비스를 위해서 어떤한 데이터 또는 리소스를 사용자에게 보여주려면 일단 서버로부터 데이터를 받아와야한다. 이제는 웹 서비스를 “웹 어플리케이션”이라고 부를만큼 많은 액션들이 동적으로 일어나는데 당연히 데이터의 변화도 많고 그만큼 서버-클라이언트의 데이터 통신도 많다. 백엔드 개발자는 보통 위 예시와 같은 각각의 endpoint를 만들고 프론트엔드 개발자가 이를 통해 데이터에 접근할수 있도록 공유 해야한다.  기존 서버-클라이언트 협업 방식에서는 연동규격서라고 하는 API 명세서를 주고 받는 절차가 반드시 필요했다. 요즘은 swagger와 같이 API 문서화 자동화 툴도 많이 사용한다. 크고 작은 프로젝트를 진행하면서…","fields":{"slug":"/graphql-query-at-front/"},"frontmatter":{"categories":"프론트엔드","title":"Graphql은 REST API의 어떤점을 해결해주나?","date":"September 17, 2021"}},"next":{"fields":{"slug":"/graphql-intro/"}},"previous":{"fields":{"slug":"/jsx-and-react-component/"}}},{"node":{"id":"06ac48d0-a881-5ea2-ab15-bda0459dff1e","excerpt":"GraphQL이 도대체 뭐야? GraphQL 얘기를 주변에서 너무 많이 들었다. 프로젝트 발표에서도 면접에서도 GraphQL 관련 질문을 받았는데..그동안 계속된 프로젝트로 새로운 기술을 배울 시간이 없었는데 도대체 GraphQL 뭔지 공부 해봐야겠다. GraphQL docs에서 제공한는 튜토이얼을 따라하기 전에 개념부터 잡고가야겠다는 생각을 했는데 마침!! kakao tech에서 정리해놓은 블로그 글을 찾았다. 카카오 테크 참고 링크 GraphQL(이하 gql)은 페이스북에서만든 쿼리 언어이고 아직 세상에 나온지 얼마되지 않은 새로운 친구이지만 2016년부터 가파르게 사용자가 늘어나고 있다고 한다. 위에서도 언급했듯이 gql은 sql과 마찬가지로 데이터를 효율적으로 요청하기 위해 사용되는 언어이지만 구조적을 큰 차이가 있고 사용 목적 또한 다르다. sql문이 데이터베이스에서 데이터를 효율적을 가져오기 위해서 사용된다면 gql은 웹 클라이언트가 서버로부터 효율적을 데이터를 받아오기…","fields":{"slug":"/graphql-intro/"},"frontmatter":{"categories":"프론트엔드","title":"Graphql은 REST API의 어떤점을 해결해주나?","date":"September 16, 2021"}},"next":{"fields":{"slug":"/createAsyncThunk/"}},"previous":{"fields":{"slug":"/graphql-query-at-front/"}}},{"node":{"id":"f70a4435-1694-5cc9-bca3-13debe15f2c0","excerpt":"🤔 리덕스는 어떻게 관리할까? 리덕스는 어떻게 관리할까? 프로젝트를 시작하면서 고민을 많이했다. 이전 프로젝트를 할때는 redux의 action과 reducer를 직접 만들어주는 방식으로 vanilla redux로 작업을했다. 마지막 6주 협업을 진행하게 되면서 분명 프로젝트의 규모가 커질것이라고 생각했고 redux-createAsyncThunk를 사용해서 비동기 미들웨어와 리듀서들을 조금더 효율적이고 간결하게 관리하기로 했다. Create Async Thunk redux 에서 비동기 처리를 할경우 보통 thunk, saga, redux-observable 등의 미들웨어를 사용하여 한개의 비동기 액션에 대해 pending(비동기 호출 전), success(비동기 호출 성공), failure(비동기 호출 실패) 의 상태를 생성하여 처리하는 경우가 많다. 이때 각 상태를 만드는것은 각자 유틸 패키지를 받거나 직접 구현하여서 사용하였는데 이를 redux-toolkit 에서 createA…","fields":{"slug":"/createAsyncThunk/"},"frontmatter":{"categories":"프론트엔드","title":"리덕스 createAsyncThunk로 비동기 처리하기","date":"July 12, 2021"}},"next":{"fields":{"slug":"/sentinel method/"}},"previous":{"fields":{"slug":"/graphql-intro/"}}},{"node":{"id":"9d8cc037-4695-54d5-b98c-e81fa24f2f3f","excerpt":"보초법 (sentinel method) 여러가지 배열 검색 방법들중 선형검색은 배열의 처음부터 마지막 또는 찾고자 하는 데이터가 나올때까지 순차적으로 모든 데이터를 비교하는 방법이다. 간단한 코드 예제 위 선형 검색은 루프가 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 계속 반복하면 종류 조건을 검사하는 cost를 무시할 수 없다. 선형 검색의 종류 조건 i == len(l)가 성립하면 (실패) a[i] == value가 성립하면 (성공) 이과정을 줄여주는 것이 보초법(sentinel method)이다.  검색하고자 하는 키값을 배열의 맨 끝에 넣어준다. 이때 저정하는 값을 보초라고 한다. 위 그림에서 볼 수 있듯이, 기존 데이터에 찾고자하는 키 값이 존재하지 않아도, 보초를 통해 검색할 값을 찾았나?라는 질문에 True를 반환하게된다. 이렇게 if 조건을 하나 단축할 수 있으며, return에서 찾은 데이터의 인덱스가 배열의 길이와 같은지 검사만 해주…","fields":{"slug":"/sentinel method/"},"frontmatter":{"categories":"알고리즘","title":"보초법","date":"June 21, 2021"}},"next":{"fields":{"slug":"/stack-and-queue/"}},"previous":{"fields":{"slug":"/createAsyncThunk/"}}},{"node":{"id":"46b8114b-691f-5c0b-a2d1-c1188bf6f21b","excerpt":"✏️ 스택 (stack) 스택은 후입선출 구조 (LIFO, Last In First Out) 구조라고 해서 한쪽 끝으로만 자료를 넣고 뺄 수 있는 자료 구조이다. 스택이 사용되는 예시 컴퓨터의 되돌리기(Ctrl + Z) 기능: 직전에 했던 행동을 되돌고 싶을 때 사용하는 기능으로, 이를 위해서는 내가 했던 행동들을 순서대로 기억해야 하므로 스택을 사용한다. 📌 특징 스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을수 있으며 데이터 접근 또한 데이터가 삽입된 top을 통해서만 접근이 가능하다. 스택의 가장 상위에 위치하는 자료는 가장 최근에 들어온 자료이며, 새로 삽입되는 자료는 top이 가리키는 자료의 위에 쌓이게 된다. 스택에서 자료를 삭제할 때도 top을 통해서만 가능하다. 스택에서 top을 통해 삽입하는 연산을 **‘push’ , top을 통한 삭제하는 연산을 ‘pop’**이라고 한다. 스택 자료구조의 기능들을 코드로 직접 구현해보자. 1. Push: 맨 …","fields":{"slug":"/stack-and-queue/"},"frontmatter":{"categories":"자료구조","title":"스택(stack)& 큐(queue)","date":"June 20, 2021"}},"next":{"fields":{"slug":"/Big-O/"}},"previous":{"fields":{"slug":"/sentinel method/"}}},{"node":{"id":"cb1ba609-d7b7-56e9-8622-fa22b6b65216","excerpt":"시간복잡도 & 공간복잡도 시간 복잡도는 코드의 실행 시간을 예측해 코드의 효율성을 나타내는 개념. 공간 복잡도는 코드의 메모리 할당이 얼마나 효율적으로 이주어지고 있는지 예측하는 개념이다. Big O 표기법 알고리즘의 성능을 수학적으로 표기하여 알고리즘의 “효율성”을 평가하는 방법. 실제 알고리즘의 정확한 러닝타임을 계산하기 보다는 알고리즘의 성능을 예측하는 것이 목표이기 때문에 Big O 표기법에서 상수는 표기하지 않는다.  O(1) -> Constant 데이터 크기에 상관없이 일정한 시간이 걸리는 알고리즘. O(n) -> Linear 선형 탐색 알고리즘과 같이 입력 테이터의 크기에 비례해 처리 시간이 증가하는 알고리즘 O(n²) -> quadratic 데이터가 증가하게되면 처리 시간이 급격하게 늘어난다.\n대표적인 예로는 이중 for문 (n² matrix)가 있다. O(nm) quadratic과 비슷하지만 두번째 loop에서 m의 크기가 n보다 작을 경우 nm으로 표기해준다. O…","fields":{"slug":"/Big-O/"},"frontmatter":{"categories":"알고리즘","title":"Big O 표기법","date":"June 19, 2021"}},"next":{"fields":{"slug":"/recursion/"}},"previous":{"fields":{"slug":"/stack-and-queue/"}}},{"node":{"id":"03fc321e-61b7-5159-bc45-8c5fb8cc7a9c","excerpt":"1. 재귀함수 📘 재귀(Recursion)은 어떠한 것을 정의할 때 자기 자신을 참조하는 것을 뜻한다. [위키백과] 어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.\n“재귀함수가 뭔가요?”\n“잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어. 마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지. 그의 답은 대부분 옳았다고 하네.\n그런데 어느날, 그 선인에게 한 선비가 찾아와서 물었어.\n“재귀함수가 뭔가요?”\n“잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을… 2. 코드 구현 숫자 세기 간단하게 60에서 0까지 숫자를 카운트하는 기능을 재귀 함수로 구현해보자. 팩토이얼 재귀함수와 관련되어 나오는 대표적인 문제인 팩토리얼 문제를 코드로 구현해보자. 팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것을 의미한다. 예제)\n3! 은 3 _ 2 _ 1 = 6,\n4! 는 4 _ 3 _ 2 _ 1 = …","fields":{"slug":"/recursion/"},"frontmatter":{"categories":"알고리즘","title":"재귀함수","date":"June 16, 2021"}},"next":{"fields":{"slug":"/binary-search/"}},"previous":{"fields":{"slug":"/Big-O/"}}},{"node":{"id":"568c79a7-da45-5fac-8938-a0b2e62940ad","excerpt":"1. 이진 탐색 배열 구조의 자료에서 특정 값을 찾는 방법은 크게 두가지가 있을 수 있다. 순차 탐색 이진탐색 순차 탐색에서는 배열의 시작부터 순차적으로 이동하며 찾고자 하는 특정 값을 모든 배열의 원소들과 비교하며 값을 찾을 때까지 반복한다. 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 출처(https://cjh5414.github.io/binary-search/) 순차 탐색과 이진탐색을 비교해보자. 순차 탐색 array 를 따라가면서 target 이 존재한다면 True 를 반환하고,\n끝까지 없다면 False 를 반환한다. 이진 탐색  1. 이진 탐색 출처(https://cjh5414.github.io/binary-search/) 순차 탐색…","fields":{"slug":"/binary-search/"},"frontmatter":{"categories":"알고리즘","title":"이진탐색","date":"June 16, 2021"}},"next":{"fields":{"slug":"/Linked List/"}},"previous":{"fields":{"slug":"/recursion/"}}},{"node":{"id":"98ad3573-309e-56f9-a3ad-f470702b58c2","excerpt":"링크드 리스트란?  링크드 리스트는 기존 배열 구조와 마찬가지로 선형 데이터 자료구조를 가진다. 배열에서는 담고있는 데이터 자체가 연속적으로 저장되어 있다면, 링크드리스트는 노드들이 포인터를 통해 연결 관계를 유지하는 리스트이며, 노드는 데이터를 저장하는 부분, 다음 노드를 가르키는 부분으로 구성되어있다. 링크리스트 장/단점: 장점 삽입과 삭제가 O(1)에 이루어진다. 삽입과 삭제를 할 때마다 동적으로 링크드 리스트의 크기가 결정되므로 전통적인 배열(Array)에 비해 처음부터 큰 공간을 할당할 필요가 없어진다. 메모리 관리가 용이하다. 단점 Random Access, 즉 배열처럼 index를 통해 탐색이 불가능하다. 탐색이 O(N)이 걸린다. (Head부터 Tail까지 모두 탐색 시) 사실상 삽입과 삭제가 왼쪽에서(Head에서) 이루어지지 않을 경우, 결국 탐색을 먼저 해야 하기 때문에 삽입과 삭제 모두 적게는 O(k)부터 최악의 경우 O(N)까지 걸릴 가능성이 있다. (출처: …","fields":{"slug":"/Linked List/"},"frontmatter":{"categories":"자료구조","title":"Linked List","date":"June 15, 2021"}},"next":{"fields":{"slug":"/sorting/"}},"previous":{"fields":{"slug":"/binary-search/"}}},{"node":{"id":"bcd5395a-292c-5d49-85e2-515194008293","excerpt":"알고리즘 공부를 시작하면서 점점 작아지는 내 모습이 안쓰러울 정도이다…처음 개발 공부를 시작할때 들었던 막막함과는 또 다른 느낌이다. 마치 끝이 보이지 않는 어두캄캄한 길을 걸어가는 느낌..다른 사람들은 당연하다고 생각하는 소스코드도 왜이렇게 이해하기가 힘든지..여튼 쉽지않은 하루를 보내고있다. ✏️ 정렬 오늘은 정렬의 여러가지 방법들을 정리하면서 배운 내용들을 다시 한번 돌아보려고 한다. 1. bubble (버블정렬) - O(n²) 버블 정렬에서는 리스트의 원소들을 처음부터 순차적으로 이동하며 인접한 두 원소의 값을 검사하고 작은 값, 또는 큰 값의 위치를 교환하며 정렬해 나가는 방법이다. 1회차의 검사가 완료되면 가장큰 원소가 자료의 맨 마지막 위치로 이동하게 되므로 2회차 검사에서는 마지막 위치의 온소는 제외하고 반목문을 실행한다. 버블 정렬의 장/단점 코드 구현이 쉽다. 최악의 경우 첫번째 위치의 원소가 마지막 위치까지 이동하기 위해서는 배열을 모든 원소들과 검사하고 교환되어…","fields":{"slug":"/sorting/"},"frontmatter":{"categories":"알고리즘","title":"정렬","date":"June 14, 2021"}},"next":{"fields":{"slug":"/reverse-string/"}},"previous":{"fields":{"slug":"/Linked List/"}}},{"node":{"id":"0f9e9d50-471c-5a96-85e7-eeda71495301","excerpt":"1. 문제 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자를 모두 0, 혹은 모두 1로 같게 만들어야 한다. 할 수 있는 행동은 연속된 하나의 숫자를 잡고 모두 뒤집는 것 이다. 뒤는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다. 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오. 예제: 예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다. 접근법: 00011000에서 연속된 하나의 숫자, 즉 연속된 문자열들을 하나의 집합으로 구분하여 생각하자. 예를들어, 00011000은 000 11 000 이렇게 구간별로 나눌 수 있다. 따라서 이 경우에 1이 나오는 구간의 문자열들을…","fields":{"slug":"/reverse-string/"},"frontmatter":{"categories":"알고리즘","title":"문자열 뒤집기","date":"June 14, 2021"}},"next":{"fields":{"slug":"/list-prime-number/"}},"previous":{"fields":{"slug":"/sorting/"}}},{"node":{"id":"08a4ad2e-e059-5570-bf26-e04017fe5d65","excerpt":"1.문제 정수를 입력 했을 때, 그 정수 이하의 소수를 모두 반환하시오. 소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다. Input = 20 접근법: 소수는 자기와 1외에는 나눌 수 없다. 소수는 2부터 n - 1까지 어떤 소수로도 나누어 떨어지지 않는다.\n(소수인지 확인하고자 하는 수가 n 일때, n이 2와3으로 나누어 떨어지지 않는다면 2x2인 4와 2x3인 6으로도 나누어 떨어지지 않는다.) n의 제좁근 이하의 어떤 소수로도 나누어 떨어지지 않는다. 풀이법: python code: 접근법: 풀이법: python code:","fields":{"slug":"/list-prime-number/"},"frontmatter":{"categories":"알고리즘","title":"소수 나열하기 [알고리즘]","date":"June 14, 2021"}},"next":null,"previous":{"fields":{"slug":"/reverse-string/"}}}],"categories":["All","프론트엔드","자료구조","알고리즘"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}